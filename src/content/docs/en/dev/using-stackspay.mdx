---
title: 'Using StacksPay'
description: 'using'
---

### 1. Generating a Payment Request

```typescript
import { STXPay } from './stxpay';

const params = {
  recipient: 'SP3FBR2AGK2YDB8XJ9THN4SR6J5SM8KW6QY6WEM9A',
  amount: '1000',
  token: 'STX',
  description: 'Payment for services',
  spId: STXPay.generateSpId(),
};

const stxPayUrl = STXPay.generate(params, 'pay');
console.log('Generated StacksPay URL:', stxPayUrl);
```

```rust
extern crate bech32;

use bech32::{ToBase32, Variant, Bech32};
use rand::Rng;
use hex_literal::hex;

fn generate_spid() -> String {
    let id: [u8; 16] = rand::thread_rng().gen();
    bech32::encode("stx", id.to_base32(), Variant::Bech32m).unwrap()
}

fn main() {
    let spid = generate_spid();
    println!("Generated StacksPay ID: {}", spid);
}
```

```python
import bech32
import os

def generate_spid():
    random_id = os.urandom(16)
    encoded = bech32.bech32_encode("stx", bech32.convertbits(random_id, 8, 5), bech32.Encoding.BECH32M)
    return encoded

spid = generate_spid()
print(f"Generated StacksPay ID: {spid}")
```

### 2. Parsing a Payment Request

```typescript
const parsedParams = STXPay.parse(stxPayUrl);
console.log(parsedParams);
```

```rust
use bech32::{FromBase32, Bech32};

fn parse_stxpay_url(url: &str) -> Result<Bech32, bech32::Error> {
    bech32::decode(url)
}

fn main() {
    let url = "stx1...";
    match parse_stxpay_url(url) {
        Ok(decoded) => println!("Decoded URL: {:?}", decoded),
        Err(e) => println!("Error parsing URL: {:?}", e),
    }
}
```

```python
import bech32

def parse_stxpay_url(url):
    hrp, data = bech32.bech32_decode(url)
    return hrp, bech32.convertbits(data, 5, 8, False)

url = "stx1..."
parsed_data = parse_stxpay_url(url)
print(f"Parsed data: {parsed_data}")
```

### 3. Encoding/Decoding with Bech32m

#### Encoding a URL:

```typescript
const encodedUrl = STXPay.encodeBech32m('stxpay://pay?recipient=SP...&amount=1000');
console.log(encodedUrl);
```

```rust
use bech32::{ToBase32, Variant};

fn encode_stxpay_url(url: &str) -> String {
    let bytes = url.as_bytes().to_base32();
    bech32::encode("stx", bytes, Variant::Bech32m).unwrap()
}

fn main() {
    let encoded_url = encode_stxpay_url("stxpay://pay?recipient=SP...");
    println!("Encoded URL: {}", encoded_url);
}
```

```python
def encode_stxpay_url(url):
    return bech32.bech32_encode("stx", bech32.convertbits(url.encode(), 8, 5), bech32.Encoding.BECH32M)

url = "stxpay://pay?recipient=SP..."
encoded_url = encode_stxpay_url(url)
print(f"Encoded URL: {encoded_url}")
```

#### Decoding a Bech32m URL:

```typescript
const decodedUrl = STXPay.decodeBech32m('stx1...');
console.log(decodedUrl);
```

```rust
use bech32::{FromBase32, Bech32};

fn decode_stxpay_url(encoded_url: &str) -> Result<Vec<u8>, bech32::Error> {
    let (_, data) = bech32::decode(encoded_url)?;
    Ok(Vec::from_base32(&data)?)
}

fn main() {
    let decoded_url = decode_stxpay_url("stx1...");
    println!("Decoded URL: {:?}", decoded_url);
}
```

```python
def decode_stxpay_url(encoded_url):
    hrp, data = bech32.bech32_decode(encoded_url)
    return hrp, bech32.convertbits(data, 5, 8, False)

encoded_url = "stx1..."
decoded_url = decode_stxpay_url(encoded_url)
print(f"Decoded URL: {decoded_url}")
```
